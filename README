- Help

$ cd scripts/; ./grc help


- Environment configuration

scripts/grc.cfg


- Building

$ ./scripts/build.sh
$ ./scripts/clean.sh


- Execution

The first three scripts have module and action settings. Running grc help should clarify things.

exec.sh			Executes grc with a single *.grc file argument
exectxt.sh		Executes grc with a single *.grc file argument and dumps output in a .txt file
execgv.sh		Executes grc with a single *.grc file argument and creates a graphviz .png file

fexec.sh		Executes exec.sh for all *.grc files in its directory argument
fexectxt.sh		Executes exectxt.sh for all *.grc files in its directory argument
fexecgv.sh		Executes execgv.sh for all *.grc files in its directory argument

allexec.sh		Executes fexec.sh for each subdirectory of code/ directory
allexectxt.sh	Executes fexectxt.sh for each subdirectory of code/ directory
allexecgv.sh	Executes fexecgv.sh for each subdirectory of code/ directory


- Examples

./grc code src ../code/01-tac/00-examples/hanoi.grc

./exec.sh ../code/01-tac/00-examples/hanoi.grc

./fexec.sh ../code/01-tac/00-examples/

./allexec.sh



- Implementation Notes

1. Abstact syntax tree

The abstract syntax tree was hand built from the resulting SableCC concrete syntax tree for maximum
flexibility plus avoiding having to struggle with possibly limited SableCC ast transformation syntax.

Nodes/Ast/

Visitors/Cst/ASTCreationVisitor.cs
Visitors/Ast/IVisitor.cs
Visitors/Ast/DepthFirstVisitor.cs


2. Semantic analysis/Type checking

Partial classes were extensively used to add members to existing classes without having them depend
on later stages of development. This is why ast node classes reappear in Nodes/Sem/ for example.
Subclassing the node classes would require downcasting in visitor methods to use their new members.

Nodes/Sem/

Visitors/Sem/SemanticVisitor.cs
Visitors/Sem/TypeVisitor.cs
Visitors/Sem/TypeResolver.cs

Symbols/

Types/

Exception/Symbols/
Exceptions/Sem/
Exceptions/Types/

The symbol table knows about parameter/variable versus function symbols (SymbolVar-SymbolFunc).
The symbol table interface can be used to insert and lookup either of these two types. This allows
for parameters/variables having the same name with functions, even in the same scope.

SemanticVisitor does very basic semantic checking without caring for types, it was used only for
development. Instead of subclassing it, its functionality was incorporated in TypeVisitor which
does complete checking.


3. Intermediate representation in three address code

Although the compiler is targeting a stack based virtual machine, the intermediate representation
was not changed from the initial three address code to a stack based form.

Nodes/Tac/

Visitors/Tac/ScopeNameVisitor.cs
Visitors/Tac/ScopeTypeVisitor.cs
Visitors/Tac/TacVisitor.cs

Quads/

Exceptions/Tac/

ScopeNameVisitor (which is a TypeVisitor) processes the initial ast and renames each function and
each corresponding function call using their ancestor functions' names so that they have unique names
throughout the program. This initially allows functions to have ancestors with the same name without
ambiguity in function calls. At a later stage the abstract syntax tree is flattened so there is an
additional requirement that each function has a unique name throughout the program. ScopeNameVisitor
provides this property for the program.

ScopeTypeVisitor is just a TypeVisitor that can type check a tree with changed names.

TacVisitor is the main three address code generation visitor, using backpatching. The resulting code
is not stored on a hash table but decorates each corresponding node of the abstract syntax tree.


4. Lambda Lifting

Nodes/Trg/

Visitors/Trg/ContextWrapper.cs
Visitors/Trg/LLTickVisitor.cs
Visitors/Trg/LLBoomVisitor.cs

Exceptions/Trg/

Two visitors are used in lambda lifting. LLTickvisitor decorates functions and their corresponding
functions calls with the free variables from the immediately enclosing scope as ref parameters. It
is used iteratively until it can make no more changes to the program. Then LLBoomVisitor does the
actual lifting, elevating each function that has no children one level above, right after its parent,
with a function declaration immediately before the parent, as it may be invoking the lifted function.
An example of the process is included under the notes/ directory, it is direct output of the compiler.

ContextWrapper just wraps the main program function in another function without parameters or return
value that just invokes it. If applied before the lambda lifting visitors, the last lambda operation
is always a boom, function declarations exist for all functions at the beginning of the output, and
the first function definition in the program is the initial main function.



- Odds and Ends

Tests:
Test cases can be found under GrcTests. All test cases pass with the current code and can be used as
documentation as to what the compiler considers legal or illegal.


Stage abbreviations:
Ast: Abstract syntax tree
Sem: Semantic analysis/Type checking
Tac: Three address code intermediate representation
Trg: Target code generation


Each ast node is decorated with:
- Its formatted source code (Text property, synthesized from own source and child nodes' source).
- Its type (Type property, set by TypeVisitor).
- Its three address code (Tac property, synthesized from own tac and child nodes' tac).


Static integer values:
A static integer value property has been added to expressions, for detecting invalid integer values
that are known at compile time.


Subclassing:
There is not a single switch statement or multiple else if statement in the project, except in
program argument passing. Extensive subclassing was used instead, inspired by SableCC's approach.
