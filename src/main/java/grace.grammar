Package k31.grc;


Helpers

	letter = [['a' .. 'z'] + ['A' .. 'Z']];
	digit = ['0' .. '9'];
	underscore = '_';

	tab = 9;
	cr = 13;
	lf = 10;

	eol = cr | lf | cr lf;
	whitespace = ' ' | tab | eol;

	printchar = [32 .. 126];
	prtabchar = [printchar + tab];

	specialchar = [[''' + '"'] + '\'];
	commonchar = [printchar - specialchar];

	hexdigit = digit | ['a' .. 'f'] | ['A' .. 'F'];
	escape = '\n' | '\t' | '\r' | '\e' | '\\' | '\' ''' | '\"' | '\x' hexdigit hexdigit;


States

	code, comment, comment_possible_end;


Tokens

// keywords

	{code} key_var = 'var';
	
	{code} key_char = 'char';
	{code} key_int = 'int';
	
	{code} key_if = 'if';
	{code} key_then = 'then';
	{code} key_else = 'else';
	{code} key_while = 'while';
	{code} key_do = 'do';
	
	{code} key_fun = 'fun';
	{code} key_ref = 'ref';
	{code} key_nothing = 'nothing';
	{code} key_return = 'return';
	

// operators

	{code} oper_plus = '+';
	{code} oper_minus = '-';
	{code} oper_mul = '*';
	{code} oper_div = 'div';
	{code} oper_mod = 'mod';
	{code} oper_hash = '#';
	
	{code} oper_eq = '=';
	{code} oper_ne = '<>';
	{code} oper_lt = '<';
	{code} oper_gt = '>';
	{code} oper_le = '<=';
	{code} oper_ge = '>=';
	
	{code} oper_and = 'and';
	{code} oper_or = 'or';
	{code} oper_not = 'not';
	

// separators

	{code} sep_lpar = '(';
	{code} sep_rpar = ')';
	{code} sep_lbrack = '[';
	{code} sep_rbrack = ']';
	{code} sep_lbrace = '{';
	{code} sep_rbrace = '}';
	{code} sep_comma = ',';
	{code} sep_colon = ':';
	{code} sep_semi = ';';
	{code} sep_assign = '<-';


// main

	{code} identifier = letter (letter | digit | underscore)*;

	{code} const_int = digit+;
	{code} const_chr = ''' (commonchar | escape) ''';
	{code} const_str = '"' (commonchar | escape)* '"';


// ignored

	// whitespace
	{code} whitespace = (whitespace)*;

	// comment line
	{code} comment_line = '$' ( [prtabchar - '$'] prtabchar* )? eol?;

	// comment span
	{code -> comment} comment_start = '$$';
	{comment_possible_end -> code} comment_end = '$'; // priority over next token
	{comment -> comment_possible_end, comment_possible_end} comment_content = ([prtabchar - '$'] | eol)* '$'?;


Ignored Tokens

	whitespace, comment_line, comment_start, comment_content, comment_end;


Productions

	prog = {expr} prog_expr
	     | {cond} prog_cond;


// constant arithmetic

	prog_expr = expr;

	expr = term expr2;
	expr2 = {add} oper_plus term expr2
	      | {sub} oper_minus term expr2
	      | {e};

	term = fact term2;
	term2 = {mul} oper_mul fact term2
	      | {div} oper_div fact term2
	      | {mod} oper_mod fact term2
	      | {e};

	fact = {int} const_int
	     | {char} const_chr
	     | {par} sep_lpar expr sep_rpar
	     | {plus} oper_plus fact
	     | {minus} oper_minus fact
	     | {lval} l_value
	     | {fun} fun_call;


// l-value

	l_value = {lval} l_value sep_lbrack expr sep_rbrack
	       | {str} const_str
	       | {id} identifier;


// function call

	fun_call = identifier sep_lpar fun_arg? sep_rpar;
	fun_arg = expr fun_arg2*;
	fun_arg2 = sep_comma expr;


// condition

	prog_cond = cond_semi*;
	cond_semi = cond sep_semi;

	cond = cond_o;

	cond_o = cond_a cond_o2;
	cond_o2 = {or} oper_or cond_a cond_o2
	        | {e};

	cond_a = cond_n cond_a2;
	cond_a2 = {and} oper_and cond_n cond_a2
	        | {e};

	cond_n = {not} oper_not cond_r
	       | {one} cond_r;

	cond_r = {par} sep_lpar cond_o sep_rpar
	       | {rel} [l]:expr rel_op [r]:expr;

	rel_op = {eq} oper_eq
	       | {ne} oper_ne
	       | {gt} oper_gt
	       | {lt} oper_lt
	       | {ge} oper_ge
	       | {le} oper_le;
